# В быстрой сортировке используется стратегия «разделяй и властвуй». Следовательно, массив должен
# разделяться до тех пор, пока мы не придем к базовому случаю.


def quicksort(array):
    # Пустые массивы и массивы, содержащие всего один элемент,
    # станут базовым случаем. Такие массивы можно просто возвращать
    # в исходном виде - сортировать ничего не нужно.
    if len(array) < 2:
        return array
    # Массив из двух элементов тоже сортируется без особых проблем.
    # Сравниваем 2 элемента: если первый элемент больше второго, меняем их местами.
    # elif len(array) == 2:
    #     if array[1] < array[0]:
    #         array[0], array[1] = array[1], array[0]
    #         return array
    else:
        # В массиве выбирается элемент, который называется опорным
        pivot = array[0]
        # Формируем подмассив элементов меньше опорного
        less = [i for i in array[1:] if i <= pivot]
        # Формируем подмассив элементов больше опорного
        greater = [i for i in array[1:] if i > pivot]
    return quicksort(less) + [pivot] + quicksort(greater)


if __name__ == '__main__':
    print(quicksort([10, 5, 15, 2, 7, 3]))  # [2, 3, 5, 7, 10, 15]
    print(quicksort([10, 5]))  # [5, 10]
    print(quicksort([5]))  # [5]
    print(quicksort([10, 5, 17]))  # [5, 10, 17]
