1. Каким будет результат деления 7//-3?
x = 7 // -3
print(x)  # -3
# Я думал, что -2, т.к. 7/-3 = -2,3(3), т.е. целочисленное деление должно дать -2
(+1: -3, т.к. результат -2,3(3) округляется в меньшую сторону, а -3 < -2)

2. Какие типы являются изменяемыми из tuple, list, dictionary, set?
tuple - неизменяемый
list - изменяемый 
dictionary - изменяемый
set - изменяемый
(+1)

3. Допустимо ли такое выражение: 1 <= a < 10 and 1 <= b < 20 ?
Да.
1 <= a < 10 это то же самое, что a >= 1 and a < 10
1 <= b < 20 это то же самое, что b >= 1 and b < 20
Условие соблюдается, например, если a == 1 и b == 1.
(+1)

4. Что будет в результате в переменной a и почему?
a = [[]]*3
print(a)  # [[], [], []]
a[0].append(3)
print(a)  # [[3], [3], [3]] 
a[1] = 1
print(a)  # [[3], 1, [3]]
Сначала переменной а присвоен список внутри списка, умноженный на 3, т.е. 3 пустых списка внутри списка.
Затем к элементу с индексом 0 каждого пустого списка добавляется элемент 3.
Наконец, элементу с первым индексом (второй список) присваивается новое значение, 1, а ссылка на список уничтожается.
(+1)

5. Что такое функциональный объект (функтор) и как его создать?
Функтор - экземпляр, который может работать как функция. Для его создания используется магический метод __call__.
(+1)

6. Что выведется на стандартный ввод/вывод при выполнении следующего кода и  почему:
class TheClass: 
    def __call__(self, n, *args, **kwargs):  # value_n, list_of_args, the_list=list_of_args
        n += 1  # 
        args[0].extend((2, 3, 4)) # Добавляет к концу списка list_of_args последовательность 2, 3, 4.
        kwargs['the_list'].remove(5) # При этом удаляется 5

value_n = 1 
list_of_args = [1, 3, 5] 
the_class = TheClass()  # Это создание функтора
the_class(value_n, list_of_args, the_list=list_of_args) 
print(value_n, list_of_args)  # 1 [1, 3, 2, 3, 4]  # value_n не изменилось, т.к. return n не было
(+1: но про return n лучше не писать, т.к. помимо него ещё нужно, чтоб вызов функции выглядел как value_n = the_class(value_n, list_of_args, the_list=list_of_args); достаточно просто указать, что value_n - неизменяемый)

7. Как добавить новый атрибут в объект класса и как предотвратить такую возможность? 
Использовать магический метод __slots__ = ('attr', 'attr1').
Можно будет использовать только те атрибуты, который указаны в нём.   
(+1: только __slots__ - это не магический метод, а специальный атрибут (поле) неизменяемого типа tuple, который заменяет __dict__  изменяемого типа "dict" у всех экземпляров данного класса)        

Итого: 7/7 - пока отлично)




