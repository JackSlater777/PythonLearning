# Теория
# 1. В каких объектах используется ключевое слово yield? (1 балл)
# В генераторах
# (+1)

# 2. Зачем нужны декораторы? (1 балл)
# Расширить функциональность кода без изменения самого кода
# (+1)

# 3. Что такое GIL? (1 балл)
# Global interpreter lock - встроенный мьютекс в python, который делает в большинстве случаев невозможным реализацию
# "истинного параллелизма" (в итоге получится реализовать только конкурентность)
# (+1)

# 4. Что выведет следующий код? (1 балл)
default_argument_value = 5

def function(argument=default_argument_value):  # аргумент принимает значение 5 (т.к. он был до описания функции)
    print(argument)

default_argument_value = 6
function()  # Вызов функции без аргумента
# Ответ: 5
# (+1: да, важный момент, что связь формального аргумента со значением по умолчанию осуществляется именно при определении функции, а не при ее вызове)

# 5. Какое выражение из перечисленных ниже является объявлением кортежа (tuple)? (1 балл)
the_tuple_1 = ()  # Это кортеж??
the_tuple_2 = 1  # Это число
the_tuple_3 = 1,  # Это кортеж
the_tuple_4 = 1, 1  # Это кортеж
# (+1: да () - это кортеж)

# 6. Что выведет следующий код и почему? (2 балла)
a = []
for i in [1, 2, 3, 4, 5]:
    a.append(lambda: i)  # Лямбде не переданы аргументы; а - список из лямбд
for fn in a:
    print(fn())  # Выведутся пятёрки, т.к. список проитерирован до конца через for
# (+2)	

# 7. Что выведет следующий код и почему? (2 балла)
class Parent:
    x = 1

class Child1(Parent):
    pass

class Child2(Parent):
    pass

# Child1 и Child2 наследуют атрибут x от Parent - будет 1 1 1
print(Parent.x, Child1.x, Child2.x)
# Задаем атрибут x у Child1
Child1.x = 2
# Сначала интерпретатор ищет атрибут у текущего класса, если его нет - у родителя.
# У Child1 есть свой атрибут x = 2, у Child2 нет (он возьмется у родителя х = 1). Поэтому 1 2 1
print(Parent.x, Child1.x, Child2.x)
# Меняем атрибут у родителя
Parent.x = 3
# Сначала интерпретатор ищет атрибут у текущего класса, если его нет - у родителя.
# У Child1 есть свой атрибут x = 2, у Child2 нет (он возьмется у родителя х = 3). Поэтому 3 2 3
print(Parent.x, Child1.x, Child2.x)
# (+2)	

# 8. Перечислите не менее 3-х способов межпроцессного взаимодействия. (1 балл)
# Модуль Multipocessing - Queue и Pipe, мьютексы (Lock), разделяемая память (Value и Array), пулл процессов (Pool)
# (+1: ну только Pool - это не способ межпроцессного взаимодействия, а способ управления процессами в Python; а вот управление это реализовано внутри Pool посредством тех же Queue, Lock и т.д.)	

# 9. Для каких типов задач, допускающих распараллеливание, использование потоков Python будет иметь смысл? (1 балл)
# Для клиент-серверного взаимодействия (I-O Bound Proccesess)
(+1)

# 10. Какой объект Python можно использовать для создания сетевого соединения? Какими параметрами инициализировать
# этот объект для соединения по IPv4 на сетевом уровне и по UDP на транспортном уровне? (1 балл)
# Объект - сокет (модуль Socket)
# AF_INET соответствует адресам IPv4
# SOCK_STREAM соотвествует протоколу TCP
(0: вопрос был про UDP!)

# 11. Какой термин используется для обозначения вспомогательных функций, используемых для подготовки тестового
# окружения перед тестом, зачистки результатов после теста и обеспечения дополнительных возможностей в самом тесте?
# (1 балл)
# Фикстуры?
(+1)

# 12. В каких целях применяется объектно-реляционное преобразование (ORM)? (1 балл)
# В целях связывания базы данных с концепциями ООП, т.е. задания работы базы данных в парадигме ООП.
(+1)